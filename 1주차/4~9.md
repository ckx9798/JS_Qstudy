<!-- @format -->

## 변수는 왜 필요할까요?

변수는 값을 저장하고 재사용하기 위해 필요하다. 만약 변수가 없다면, 값을 저장할 때마다 메모리 주소를 직접 기억하거나 사용해야 하므로 코드가 복잡해지고 오류가 발생할 가능성이 높아진다. 변수는 이러한 값을 저장할 수 있는 메모리 공간을 의미하며, 이 공간에 이름(식별자)을 붙여 사람이 이해하기 쉽게 만든다. 덕분에 개발자는 변수명을 통해 값을 쉽게 저장하고, 필요할 때마다 재사용하거나 변경할 수 있다.

"변수가 없으면 메모리 주소를 통해 값에 직접 접근해야 하는데 이는 치명적 오류를 발생시킬 가능성이 높다. 변수는 컴파일러 또는 인터프리터가 값을 저장하고 참조할 수 있도록 도준다.

## 식별자와 변수의 차이점에 대해 설명해주세요

![](https://velog.velcdn.com/images/ckx12/post/a706967a-b3cb-481e-8ebe-8570046ec368/image.png)
변수는 실제로 데이터를 저장하는 메모리 공간 또는 그 공간을 가리키는 이름 자체를 뜻한다.

식별자는 변수뿐 아니라 함수, 클래스 등 모든 메모리 공간을 구별할 수 있는 이름을 의미하며, 변수명도 식별자의 한 종류다.

비유하자면, 변수는 서랍이고, 식별자는 서랍에 붙인 라벨이다. 라벨(식별자)을 통해 여러 서랍(변수) 중 원하는 값을 쉽게 찾을 수 있다.

## 10+20 을 만났을때 일어나는 일

1. 리터럴 + 연산자를 확인 => 숫자리터럴과 산술연산자
2. 두가지를 더해 하나의 표현식으로 구성
3. 표현식을 이해하게 끔 파싱 후 연산
   - 10 / 20 을 각각 메모리에 저장 후
   - 산술연산자가 더한 결과인 30을 반환
4. 반환된 30을 메모리에 저장
5. 저장된 30을 변수에 할당

## 변수에 값을 할당했을 때 일어나는 일에 대해

1. 메모리 공간 확보 및 식별자 설정
   컴퓨터는 변수를 선언하면, 해당 변수만을 위한 메모리 공간을 확보하고, 그 공간에 식별자(이름)를 붙인다.

   - 예: let x; → x라는 이름으로 메모리 공간 예약.

2. 값을 메모리에 저장
   할당 연산자(=)를 사용해 값을 변수에 저장하면, 그 값이 메모리 어딘가에 저장된다.

3. 식별자와 값(또는 값의 주소) 연결
   변수(예: x)는 그 값이 저장된 위치(주소) 또는 값 자체를 가리키도록 연결된다. 즉, 식별자와 메모리 주소가 매핑된다.

🔍 var, let의 선언/할당 차이 (호이스팅)

- var: 변수 선언이 코드의 어디에 있든 런타임 이전에 미리 메모리에 공간이 확보되고, 자동으로 undefined로 초기화된다. 그래서 선언 전에 참조해도 에러가 나지 않고 undefined가 반환된다.

- let: 선언은 호이스팅되지만, 실제로 초기화되기 전까지는 TDZ(일시적 사각지대)에 머문다. 선언문에 도달해야 비로소 초기화와 할당이 동시에 이루어진다. 따라서 선언 전에 참조하면 에러(ReferenceError)가 발생한다.

## let은 왜 굳이 초기화를 할까?

선언문 이전까지 TDZ를 유지하며 참조에러를 반환한다
선언문을 마주치면 바로 할당을 하면되는데
왜 굳이 초기화 과정을 거칠까?

1. TDZ(Temporal Dead Zone)와 안전성

let 변수는 선언 전에 접근하면 ReferenceError가 발생한다. 이는 "일시적 사각지대(TDZ)" 때문이다.
TDZ는 변수 선언이 스코프의 맨 위에서 시작해, 선언문을 만날 때까지 유지된다.

이 구간에서는 변수의 메모리 공간은 이미 확보되어 있지만, **초기화(=엔진이 변수에 접근 가능하다고 표시)**가 되지 않은 상태다.
즉, "이 변수는 아직 쓸 준비가 안 됐으니 접근하지 마!"라는 안전장치다.

2. 초기화의 의미

let 변수의 초기화는 "이제부터 이 변수에 접근해도 된다"는 신호다.
초기화가 끝나야 비로소 변수에 값을 할당하거나 읽을 수 있다.
만약 선언과 동시에 값을 할당하지 않으면, undefined로 초기화된다.

3. 왜 굳이 초기화 과정을 거칠까?

스코프 내 변수의 상태를 명확히 구분하기 위해서다.
TDZ 구간: 변수는 존재하지만, 초기화되지 않아 접근 불가(ReferenceError).

선언문 도달 시: 변수 초기화, 이후 접근 가능.

즉, **"메모리 공간 확보 → 초기화 → 값 할당"**의 3단계로 변수의 생명주기를 명확히 나눠,
예기치 않은 버그(특히 var의 호이스팅 부작용)를 방지한다.

선언문에 도달하자마자 값을 할당하게 만들면,
변수 선언만 하고 값을 나중에 할당하는 패턴(let foo; foo = 10;)을 사용할 수 없게 된다.

또한, 초기화 과정을 통해 "선언만 된 변수"와 "아예 없는 변수"를 구분할 수 있다.

- 일관성
  JS엔진은 항상 선언-초기화-할당 단계를 유지한다
  그래서 let도 일관성을 위해 초기화 단계를 거친다

## 왜 자바스크립트는 호이스팅이 되게끔 설계되었을까?

1. 초보자 친화적이고 유연한 문법

자바스크립트는 웹에 동적인 기능을 쉽게 추가할 수 있도록, 초보자도 부담 없이 사용할 수 있는 언어로 설계되었다.

그래서 함수나 변수를 코드 어디서든 자유롭게 선언하고 사용할 수 있게 했고, 선언 위치에 상관없이 동작하는 것이 직관적이고 편리하다고 여겨졌다.

예를 들어, 아래와 같이 함수 선언문이 호출보다 아래에 있어도 정상적으로 동작한다.

```js
sayHi(); // 실행됨

function sayHi() {
  console.log("안녕!");
}
```

이는 초보자에게 "코드가 위에서 아래로만 읽힌다"는 부담을 줄이고, 선언 위치에 덜 민감하게 코딩할 수 있게 해준다.

2. 인터프리터 방식과 실행 컨텍스트 구조

자바스크립트 엔진은 코드를 실행하기 전에 파싱(분석) 단계에서 변수와 함수 선언을 미리 수집해 메모리에 등록한다.

그 후 실제 실행 단계에서는 코드가 위에서 아래로 순차적으로 실행된다.

이 구조 덕분에, 실행 전에 이미 변수와 함수의 선언 정보를 알고 있으므로, 선언 위치에 상관없이 스코프 내에서 참조가 가능하다.

3. 호이스팅이 없다면 생기는 문제

만약 호이스팅이 없다면, 코드가 실행되는 도중 선언되지 않은 변수나 함수를 만날 때마다 즉시 에러가 발생한다.

이렇게 되면 코드를 한 줄씩 실행할 때마다 선언 여부를 계속 확인해야 하고, 스코프 구조도 동적으로 계속 바뀌어야 한다.

이는 실행 효율성 저하와 함께, 개발자가 코드의 선언 순서에 지나치게 신경 써야 하는 불편함을 초래한다.

## 값, 표현식, 리터럴의 차이

| 용어                   | 뜻                                                          |
| ---------------------- | ----------------------------------------------------------- |
| **값(value)**          | 계산 결과, 메모리에 저장되는 실제 데이터                    |
| **표현식(expression)** | **값을 만들어내는 코드 조각**                               |
| **리터럴(literal)**    | 값을 직접 **"있는 그대로" 표현한 것** (예: `42`, `"hello"`) |

| 표현식      | 설명              | 결과 값      |
| ----------- | ----------------- | ------------ |
| `2`         | 리터럴이자 표현식 | 2            |
| `2 + 3`     | 산술 표현식       | 5            |
| `"a" + "b"` | 문자열 표현식     | "ab"         |
| `x > 5`     | 비교 표현식       | true / false |

**리터럴(literal)**은 소스 코드에서 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 직접 표현하는 표기법이다. 예를 들어, 3, 'Hello', null, [1,[2][3], { name: "Alice" }, function() {} 등이 모두 리터럴이다. 즉, 리터럴은 "값 자체"를 코드에 직접 적어놓은 것이다.

**표현식(expression)**은 "값으로 평가될 수 있는 문"이다. 즉, 표현식은 평가(실행)하면 값이 된다. 예를 들어, 3, 3 + 4, x, sum = 10, arr, function() {} 등은 모두 표현식이다. 리터럴은 그 자체로 표현식이기도 하다. 왜냐하면 리터럴을 평가하면 바로 값이 나오기 때문이다.

리터럴 → 값 자체(3, 'hi', [], {}, function() {})

표현식 → 값으로 평가될 수 있는 문(3, 3+4, x, sum = 10, arr, function() {})

**값(value)**은 표현식이 평가된 결과다. 즉, 리터럴이든, 변수든, 연산의 결과든, 결국 모든 것은 값으로 귀결된다.

## 표현식인 문과 표현식이 아닌 문

자바스크립트에서 **문(statement)**은 프로그램을 구성하는 최소 실행 단위다. 문에는 다음과 같은 종류가 있다:

표현식인 문: 평가하면 값이 되는 문. 예) x = 1 + 2;, sum = 10;, console.log('hi');

표현식이 아닌 문: 값으로 평가될 수 없는 문. 예) 변수 선언문(var x;), 함수 선언문(function foo() {}), if문, for문 등

구분법:
표현식인 문은 변수에 할당할 수 있다.
표현식이 아닌 문은 변수에 할당할 수 없다.

### 🔍 함수

```js
//함수 선언문
function foo() {}
```

    - 값으로 평가되지 않는다(표현식이 아님).
    - 따라서 변수에 할당할 수 없다.

```js
//함수 리터럴(함수 표현식):
var bar = function () {};
```

    - 값으로 평가된다(표현식).
    - 변수에 할당할 수 있다.

함수 리터럴은 값처럼 취급되어, 할당 연산자의 우변 등 "값이 필요한 자리"에 올 수 있다.

호이스팅이 다르게 동작한다(선언 전에 사용할 수 없음).

> 함수 선언문은 "문"이므로 값으로 평가되지 않지만, 함수 리터럴은 "표현식"이므로 값으로 평가된다. 함수 리터럴(표현식)은 변수에 할당할 수 있고, 함수 선언문은 할당할 수 없다

## 동적 타입 언어 vs 정적 타입 언어: 차이점과 장단점

![](https://velog.velcdn.com/images/ckx12/post/8b59f5d6-50e8-4356-a25e-e88463b21f0f/image.png)

### 정적언어

- 정적 타입 언어의 장점

타입 안정성: 타입 에러를 컴파일 시점에 미리 발견할 수 있어 런타임 에러를 줄일 수 있음.

실행 속도: 타입이 미리 결정되어 있어 최적화된 코드 생성이 가능, 실행 속도가 빠름.

가독성/유지보수성: 타입이 명확하게 드러나 협업이나 장기 유지보수에 유리함.

- 정적 타입 언어의 단점

코드 작성 번거로움: 변수 선언마다 타입을 명시해야 하므로 코드가 길어질 수 있음.

유연성 부족: 타입이 고정되어 있어 다양한 타입의 데이터를 유연하게 다루기 어려움.

### 동적언어

- 동적 타입 언어의 장점

코드 작성이 간편: 타입 선언 없이 변수에 값만 할당하면 되므로 빠르고 짧은 코드 작성이 가능.

유연성: 변수에 다양한 타입의 값을 자유롭게 할당할 수 있어 개발 속도가 빠름.

학습 곡선이 낮음: 타입 규칙이 적어 초보자도 쉽게 접근 가능.

- 동적 타입 언어의 단점

런타임 에러 가능성: 실행 중에 타입 에러가 발생할 수 있어, 복잡한 코드에서는 버그 추적이 어려움.

타입 안정성 낮음: 코드가 길고 복잡해질수록 타입 관련 버그가 숨어 있을 가능성이 높음.

실행 속도 저하: 타입 체크가 런타임에 이뤄져 최적화가 어렵고, 실행 속도가 느릴 수 있음.

## 옵셔널 체이닝을 쓸 수 있는 실제 상황 (API 호출 예시)

객체의 속성 중간에 undefined나 null이 있어도 에러 없이 안전하게 접근할 수 있게 해주는 문법

```js
// 서버에서 받아온 사용자 정보 (종종 일부 정보가 빠져 있음)
const user = {
  id: 1,
  name: "루비",
  address: {
    city: "Seoul",
    zip: "12345",
  },
};

// 옵셔널 체이닝 없이
console.log(user.address.city); // → 정상 출력: 'Seoul'

// 근데 만약 address가 undefined면?
const user2 = {
  id: 2,
  name: "이름만 있는 사용자",
};

console.log(user2.address.city); // ❌ TypeError: Cannot read properties of undefined
```

데이터가 다른 경우에 매우 유용하다

```js
console.log(user2.address?.city); // → undefined (에러 ❌)
```

> - API 응답 객체가 복잡하거나 필드가 가끔 빠질 때

- null이나 undefined일 가능성이 있는 중첩 데이터에 접근할 때
- 중 에러 방지하고, 그냥 undefined 받고 지나가고 싶을 때
