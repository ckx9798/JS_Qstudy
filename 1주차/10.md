<!-- @format -->

# ⭐10장 객체

## 1️⃣ 객체는 변경 가능한 값인가?

객체는 변경 가능한 값, 즉 **mutable(뮤터블)**한 데이터이다.

자바스크립트에서 기본형(primitive) 값인 숫자, 문자열, 불리언, null, undefined 등은 변경할 수 없는 **불변값(immutable)**이지만, 객체는 그와 반대로 내부 데이터를 자유롭게 변경할 수 있다. 심지어 const 키워드로 선언된 객체도 내부 속성(property)은 수정할 수 있다.

```js
const person = {
  name: "지수",
};

person.name = "민수"; // 객체의 프로퍼티는 수정 가능
console.log(person.name); // 출력: 민수
```

이처럼 객체는 **참조(reference)**를 기반으로 메모리에 저장되기 때문에, 변수는 그 객체를 가리키는 역할만 하고, 객체 자체는 메모리 어딘가에 계속 존재한다. 그래서 person이라는 변수는 고정된 객체를 참조하고 있고, 객체 내부 값만 바뀌는 것이다.

단, 객체 자체를 통째로 다른 객체로 바꾸는 것은 const 변수에서는 불가능하다.

## 2️⃣ 객체 vs 인스턴스

자바스크립트에서 **객체(Object)**와 **인스턴스(Instance)**는 비슷해 보이지만, 그 의미에는 분명한 차이가 존재한다.

**객체(object)**란, 이름(key)과 값(value)으로 이루어진 데이터의 집합이다.
`{}`를 사용하여 만들 수 있으며, 특별한 틀 없이도 자유롭게 사용 가능하다.

**인스턴스(instance)**란, 특정 생성자 함수 또는 클래스에 의해 생성된 객체를 의미한다.
즉, 인스턴스는 객체의 하위 개념이라고 볼 수 있다.

결론적으로,

모든 인스턴스는 객체이지만, 모든 객체가 인스턴스인 것은 아니다.

> => 인스턴스가 더 큰 개념이다

```js
function Animal(name) {
  this.name = name;
}

const cat = new Animal("나비"); // cat은 Animal의 인스턴스
```

위 코드에서 cat은 Animal 생성자를 통해 만들어졌기 때문에 Animal의 인스턴스이며 동시에 객체이기도 하다. 하지만 단순히 아래와 같이 만든 객체는 인스턴스가 아니다.

```js
const dog = { name: "초코" }; // 객체는 맞지만, 특정 생성자의 인스턴스는 아님
```

## 3️⃣ 자바스크립트에서는 객체를 생성하는 방법이 매우 다양하다. 어떤 차이가 있을까?

1. 객체 리터럴: 가장 단순하고 직관적인 방법이다. 중괄호 {}를 사용하여 직접 key-value 쌍을 작성한다.

```js
const obj = { name: "철수" };
```

2. 생성자 함수(Constructor Function): 같은 구조의 객체를 여러 개 만들 때 사용된다.

```js
function Person(name) {
  this.name = name;
}

const p = new Person("영희");
```

3. 클래스(Class): ES6에서 도입된 문법으로, 객체지향 방식에 더 가깝다.

```js
class Person {
  constructor(name) {
    this.name = name;
  }
}

const p = new Person("민수");
```

4. Object 생성자: 자바스크립트 내장 생성자인 Object()를 이용하는 방식이다.

```js
const o = new Object();
o.name = "지훈";
```

🔍 그렇다면 왜 이렇게 다양한 방식이 존재할까?

이는 자바스크립트가 유연하고 범용적인 언어이기 때문이다.

단순한 데이터를 다룰 때는 리터럴 방식이 간편하고 직관적이다.

동일한 구조를 반복해서 만들고자 할 때는 생성자 함수나 클래스를 쓰는 것이 코드 재사용성과 유지보수 측면에서 유리하다.

특별한 제어가 필요한 경우(예: 상속, 메서드 추가 등)는 클래스 기반 설계가 더 적합하다.

즉, 상황에 맞게 객체를 만드는 방식을 선택할 수 있도록 다양한 방법이 제공되는 것이다.

## 4️⃣ 객체 안에 존재하지 않는 프로퍼티를 참조하면 왜 undefined가 반환될까?

객체에서 존재하지 않는 속성(프로퍼티)을 참조하면, 자바스크립트는 에러를 발생시키지 않고 undefined를 반환한다.

```js
const user = { name: "하나" };
console.log(user.age); // undefined
```

이러한 동작은 자바스크립트가 갖고 있는 **동적 구조(Dynamic Structure)**의 특성 때문이다.
자바스크립트 객체는 정해진 틀 없이도 자유롭게 속성을 추가하거나 삭제할 수 있는 구조로 설계되어 있다. 그래서 객체에 없는 속성에 접근하더라도, 존재하지 않는다고 판단하여 단순히 undefined를 반환하는 것이다.

이는 개발자에게 큰 유연성을 주지만, 실수로 잘못된 키를 참조해도 에러가 나지 않기 때문에 예외 처리를 반드시 해야 한다.

```js
if (user.age !== undefined) {
  console.log("나이 정보 있음");
} else {
  console.log("나이 정보 없음");
}
```

만약 이러한 유연성을 제한하고 싶다면, 타입스크립트 등 정적 타입 언어를 도입하는 것이 좋은 방법이 될 수 있다.

## 5️⃣ obj를 할당하기 전에 참조하면 어떻게 될까?

```js
console.log(obj); // ❓
const obj = { name: "지수" };
```

이때 발생하는 결과는 obj의 값과는 무관하다.
실제로 어떤 에러가 발생하는지는 변수 선언 방식인 var, let, const 중 어떤 것으로 선언되었는지에 따라 달라진다.

🔍 변수 선언 방식에 따른 차이:

| 선언 방식      | 선언 전 참조 시 결과                                  |
| -------------- | ----------------------------------------------------- |
| `var`          | `undefined` 반환 (호이스팅됨)                         |
| `let`, `const` | ❌ `ReferenceError` 발생 (호이스팅은 되지만 TDZ 때문) |

```js
console.log(x); // undefined
var x = 10;

console.log(y); // ❌ ReferenceError
let y = 10;
```

var는 선언 자체가 호이스팅되어 위로 끌어올려지기 때문에 참조가 가능하지만, 값은 아직 초기화되지 않아 undefined가 나온다.

반면, let과 const는 호이스팅은 되지만 **TDZ(Temporal Dead Zone)**라는 구간이 있어서, 선언 전에 참조하면 에러가 발생하게 설계되어 있다.

따라서 obj를 선언 전에 참조하면 무조건 에러가 나는 것이 아니라, 어떤 방식으로 선언했는지에 따라 결과가 달라진다.

## 6️⃣ 객체 내부 속성 접근: obj.age와 그냥 age의 차이

```js
const obj = {
  name: "지수",
};

console.log(age); // ❌ ReferenceError
console.log(obj.age); // ✅ undefined
```

여기서 두 줄은 비슷해 보이지만 전혀 다른 동작을 한다.

a. console.log(age)
이 코드는 age라는 전역 변수를 찾는다.

그런데 그런 변수가 어디에도 정의되어 있지 않기 때문에,
자바스크립트는 **ReferenceError(참조 에러)**를 발생시킨다.

b. console.log(obj.age)
이 코드는 obj라는 객체 안에 "age"라는 **속성(property)**을 찾는다.

객체 내부에 해당 키가 존재하지 않으면, 자바스크립트는 단순히 undefined를 반환한다.
즉, 없는 속성에 접근해도 에러가 나지 않는다.

## 7️⃣ 왜 없는 속성에 접근해도 undefined가 반환될까?

이는 자바스크립트 객체의 핵심 특징인 "동적 구조(Dynamic Structure)" 때문이라고 할 수 있다.

자바스크립트에서 객체는 정해진 틀이 없이, 필요에 따라 속성을 추가하거나 제거할 수 있도록 설계되어 있다. 즉, 객체는 항상 '변화할 준비'가 되어 있는 구조인 것이다.

그래서 다음과 같은 코드도 아무 문제 없이 실행된다.

```js
const obj = { name: "지수" };

console.log(obj.age); // undefined

obj.age = 25;
console.log(obj.age); // 25
```

이처럼 자바스크립트는 객체 내부에 해당 키가 있는지만 검사하고, 없다면 undefined를 반환하도록 설계되어 있다. 이것이 바로 객체가 동적 구조를 갖는다는 뜻이다.

📌 정리하면,

객체는 속성의 유무에 관계없이 키를 조회할 수 있고,
존재하지 않으면 에러가 아닌 undefined를 반환한다.
이는 언제든지 해당 키를 추가할 수 있도록 하기 위한 자바스크립트의 유연성이다.

## 8️⃣ obj["age"]와 obj[age]의 차이점

자바스크립트에서 객체의 속성에 접근할 때는 . 연산자 또는 [] 대괄호 표기법을 사용할 수 있다. 이 두 가지 방식은 겉보기엔 비슷해 보이지만, 중요한 차이가 있다.

```js
const obj = { name: "지수" };

console.log(obj["age"]); // undefined
console.log(obj[age]); // ❌ ReferenceError
```

이 코드에서 obj["age"]는 문자열 "age"를 키로 인식하여 객체의 속성에 접근한다.
객체 안에 "age"라는 키가 존재하지 않으면 undefined를 반환한다.

반면, obj[age]는 "age"라는 문자열이 아닌, 변수 age의 값을 키로 삼는다.
만약 해당 변수가 선언되어 있지 않다면, **자바스크립트는 변수 자체를 찾을 수 없기 때문에 ReferenceError(참조 에러)**가 발생한다.

요약:

| 코드         | 설명                        | 결과                            |
| ------------ | --------------------------- | ------------------------------- |
| `obj["age"]` | 문자열 `"age"`를 키로 접근  | `undefined` (없는 키이므로)     |
| `obj[age]`   | 변수 `age`의 값을 키로 사용 | ❌ `ReferenceError` (변수 없음) |

## 9️⃣ 객체의 동적 구조 vs 정적 구조

자바스크립트의 객체는 **동적 구조(dynamic structure)**를 가지고 있다.
이는 객체가 속성의 존재 여부와 관계없이 유연하게 속성을 추가하거나 삭제할 수 있음을 의미한다.
반대로, Java나 C 같은 언어에서는 **정적 구조(static structure)**를 따르기 때문에 사전에 정의된 속성 외에는 사용할 수 없다.

a. 정적 구조의 예: Java

```java
class Person {
  String name;
  int age;
}

Person a = new Person();
a.name = "민준";
a.job = "개발자"; // ❌ 컴파일 에러
```

정적 구조에서는 Person 클래스에 job이라는 필드를 정의하지 않았다면, 이를 사용하려는 시점에서 컴파일 에러가 발생한다.
즉, 객체의 속성은 사전에 선언되어 있어야 하며, 선언되지 않은 속성은 아예 접근이 불가능하다.

b. 동적 구조의 예: JavaScript

```js
const person = { name: "민준" };

person.age = 20; // 키 추가 가능
delete person.name; // 키 삭제 가능
console.log(person.job); // 없는 키 접근 → undefined
```

자바스크립트에서는 객체가 마치 속성을 담는 상자처럼 동작한다.
필요에 따라 얼마든지 새로운 속성을 추가하거나 기존 속성을 삭제할 수 있다.
또한 존재하지 않는 속성에 접근해도 에러가 발생하지 않으며, 단순히 undefined를 반환하도록 설계되어 있다.

이러한 구조 덕분에 자바스크립트는 동적으로 변하는 데이터 구조를 다루는 데 매우 유리하며, 초기 웹 개발 목적에 적합한 유연성을 제공한다.

# 10장 마무리

| 번호 | 질문/주제                                       | 핵심 요약                                                                                                                                                                                                |
| ---- | ----------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1️⃣   | 객체는 변경 가능한 값인가?                      | 객체는 \*\*mutable(변경 가능)\*\*한 값이다. `const`로 선언해도 내부 속성은 자유롭게 수정할 수 있다.                                                                                                      |
| 2️⃣   | 객체 vs 인스턴스                                | **인스턴스는 특정 생성자나 클래스에서 만들어진 객체**이다. 모든 인스턴스는 객체지만, 모든 객체가 인스턴스는 아니다.                                                                                      |
| 3️⃣   | 객체 생성 방법이 다양한 이유                    | 자바스크립트는 **유연한 언어**이기 때문에 상황에 맞게 객체를 만들 수 있도록 여러 생성 방식(리터럴, 생성자, 클래스 등)을 제공한다.                                                                        |
| 4️⃣   | 없는 프로퍼티를 참조하면 왜 undefined가 나올까? | 자바스크립트 객체는 **동적 구조**를 갖기 때문에, 없는 속성은 단순히 `undefined`를 반환한다. 이는 유연성을 높이기 위한 설계이다.                                                                          |
| 5️⃣   | 객체를 선언 전에 참조하면 어떤 일이 발생할까?   | `const`나 `let`은 \*\*TDZ(Temporal Dead Zone)\*\*로 인해 `ReferenceError`가 발생하며, `var`는 `undefined`를 반환한다. 이는 변수 선언 방식에 따라 달라진다.                                               |
| 6️⃣   | `age` vs `obj.age`                              | `age`는 **존재하지 않는 전역 변수**로 참조 시 에러 발생. `obj.age`는 객체의 **존재하지 않는 속성**으로 `undefined`를 반환한다.                                                                           |
| 7️⃣   | `obj.age`가 undefined를 반환하는 이유           | 객체는 **언제든 속성을 추가할 수 있는 동적 구조**이기 때문에, 없는 키에 접근해도 에러가 아닌 `undefined`를 반환하도록 설계되어 있다.                                                                     |
| 8️⃣   | `obj["age"]` vs `obj[age]`                      | `"age"`는 문자열로 인식되어 키로 접근, 변수 `age`는 실제 변수 값을 키로 사용. 변수 `age`가 선언되어 있지 않다면 `ReferenceError`가 발생한다.                                                             |
| 9️⃣   | 동적 구조 vs 정적 구조                          | **정적 구조**(예: Java)는 미리 정의된 속성만 사용 가능하고, 없는 속성 접근 시 컴파일 에러가 발생한다. 반면, **동적 구조**(예: JS)는 속성 추가/삭제가 자유롭고, 없는 속성 접근 시 `undefined`를 반환한다. |
