<!-- @format -->

## Q1. 정적 스코프와 동적 스코프의 차이점은 무엇인가요?

### A1. 변수 참조 기준이 다릅니다

정적 스코프(Lexical Scope)와 동적 스코프(Dynamic Scope)는 **변수를 찾는 기준**이 근본적으로 다릅니다.

| 구분            | 정적 스코프                 | 동적 스코프                     |
| --------------- | --------------------------- | ------------------------------- |
| **기준**        | 코드를 작성한 위치          | 함수를 호출한 위치              |
| **변수 참조**   | 함수가 정의된 위치 기준     | 함수가 실행된 위치 기준         |
| **예측 가능성** | 높음 (컴파일 시 결정)       | 낮음 (실행 시점까지 알 수 없음) |
| **언어 예시**   | JavaScript, C, Java, Python | Bash, Emacs Lisp                |

```javascript
let x = 1;

function foo() {
  console.log(x);
}

function bar() {
  let x = 2;
  foo();
}

bar();
```

- **정적 스코프 (JavaScript)**: `foo()`는 정의된 전역 위치를 기준으로 `x`를 찾아 **1**을 출력
- **동적 스코프 (가정)**: `foo()`가 `bar()` 내에서 호출되었으므로 `bar()`의 `x = 2`를 참조하여 **2**를 출력

대부분의 현대 언어가 정적 스코프를 채택하는 이유는 **가독성과 예측 가능성** 때문입니다.

---

## Q2. 함수의 [[Environment]]와 실행 컨텍스트의 외부 렉시컬 환경 참조의 관계는?

### A2. 정의 시점과 실행 시점의 연결고리입니다

| 개념                       | 설명                                                  | 역할                 |
| -------------------------- | ----------------------------------------------------- | -------------------- |
| **함수의 [[Environment]]** | 함수 정의 시 상위 스코프 참조를 저장하는 내부 슬롯    | 스코프 체인의 출발점 |
| **외부 렉시컬 환경 참조**  | 함수 실행 시 실행 컨텍스트에서 상위 환경과의 연결고리 | 스코프 체인 연결     |

**동작 과정:**

1. **함수 정의 시**

```javascript
function outer() {
  let a = 10;

  function inner() {
    console.log(a);
  }

  return inner;
}
```

`inner` 함수가 정의되면서 `inner.[[Environment]] = outer의 렉시컬 환경`이 저장됩니다.

2. **함수 실행 시**

```javascript
const fn = outer();
fn(); // inner 실행
```

`inner()` 실행 시 새로운 실행 컨텍스트가 생성되고, 그 컨텍스트의 외부 렉시컬 환경 참조에 `[[Environment]]` 값이 바인딩됩니다.

---

## Q3. [[Scopes]]와 [[Environment]]는 같은 것인가요?

### A3. 아닙니다. 용도와 표준 여부가 다릅니다

| 항목          | [[Environment]]                     | [[Scopes]]                  |
| ------------- | ----------------------------------- | --------------------------- |
| **위치**      | 함수 객체의 내부 슬롯               | 브라우저 개발자 도구        |
| **생성 시점** | 함수 정의 시점                      | 함수 정의 시점              |
| **역할**      | 상위 렉시컬 환경 참조 (클로저 핵심) | 디버깅용 스코프 체인 시각화 |
| **표준 여부** | ✅ ECMAScript 정식 표준             | ❌ 비표준 (브라우저 구현)   |

`[[Environment]]`는 실제 클로저 동작을 담당하는 핵심 구조이고, `[[Scopes]]`는 개발자의 디버깅 편의를 위한 시각적 도구입니다.

---

## Q4. 클로저의 성립 조건은 무엇인가요?

### A4. 두 가지 핵심 조건이 필요합니다

클로저가 성립하려면 다음 조건을 만족해야 합니다:

1. **외부 함수보다 오래 살아남는 중첩 함수**

   - 내부 함수가 외부 함수의 생명주기보다 길어야 함
   - 외부 함수 실행이 끝난 후에도 내부 함수가 호출 가능해야 함

2. **중첩 함수가 외부 함수의 지역 변수를 참조**
   - 내부 함수가 외부 함수의 변수에 접근해야 함
   - 이 참조가 클로저 발생의 트리거

**예제:**

```javascript
function outer() {
  let secret = "비밀 정보";

  return function inner() {
    console.log(secret); // 외부 변수 참조
  };
}

const fn = outer(); // outer 종료, inner만 남음
fn(); // 클로저로 인해 'secret'에 접근 가능
```

---

## Q5. 자유 변수(Free Variable)란 무엇인가요?

### A5. 자신의 스코프에서 선언되지 않았지만 사용하는 변수입니다

자유 변수는 **함수 내부에서 선언되지 않았지만 참조되는 변수**를 의미합니다.

**예제:**

```javascript
const x = 10; // 전역 변수

function printX() {
  console.log(x); // x는 printX의 자유 변수
}

function outer() {
  const secret = "비밀";

  return function inner() {
    console.log(secret); // secret은 inner의 자유 변수
  };
}
```

| 변수 종류       | 설명                                 | 예시                    |
| --------------- | ------------------------------------ | ----------------------- |
| **자유 변수**   | 함수 내 선언 안 됐지만 참조되는 변수 | 위 예제의 `x`, `secret` |
| **바운드 변수** | 함수 내부에서 선언된 변수            | `let y = 2`             |

자유 변수를 참조하는 함수가 바로 **클로저가 되는 조건**을 만족합니다.

---

## Q6. 클로저를 사용하는 이유는 무엇인가요?

### A6. 상태 관리, 정보 은닉, 스코프 보호가 주된 목적입니다

클로저를 사용하는 세 가지 주요 이유:

### 1️⃣ **상태(State) 기억 및 관리**

```javascript
function createCounter() {
  let count = 0;

  return function () {
    return ++count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

### 2️⃣ **정보 은닉 (Private 변수)**

```javascript
function createUser(name) {
  let _name = name; // private 변수

  return {
    getName() {
      return _name;
    },
    setName(newName) {
      _name = newName;
    },
  };
}

const user = createUser("김철수");
console.log(user.getName()); // "김철수"
// user._name에 직접 접근 불가
```

### 3️⃣ **콜백에서 스코프 보호**

```javascript
// 문제가 있는 코드
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 3, 3, 3
  }, 1000);
}

// 클로저로 해결
for (var i = 0; i < 3; i++) {
  (function (index) {
    setTimeout(function () {
      console.log(index); // 0, 1, 2
    }, 1000);
  })(i);
}
```

### 클로저 사용의 핵심 가치:

- **캡슐화**: 상태와 동작을 하나로 묶음
- **정보 보호**: 의도치 않은 변경 방지
- **결합도 감소**: 안전한 모듈 설계
