<!-- @format -->

자바스크립트에서 객체를 복사할 때 "복사"는 전부 같은 의미가 아닙니다.
특히, 복사를 했다고 해서 완전히 새로운 데이터가 만들어지는 것은 아닙니다.
**얕은 복사(Shallow Copy)**와 **깊은 복사(Deep Copy)**를
메모리 주소 개념과 함께 쉽게 풀어보겠습니다.

## 📌 기본 개념 먼저 정리

```js
const obj = { a: 1, b: [10, 20, 30] };
```

여기서 obj는 어떤 메모리 주소, 예를 들어 "주소1"을 가리킵니다.
내부의 배열 b는 "주소배열"이라는 또 다른 메모리 공간에 따로 저장됩니다.

### 1️⃣ 참조 복사 (주소만 복사)

- 얕은복사라 부르지만 사실은 `참조 전달`

```js
const obj3 = obj;
```

obj3는 obj와 **같은 메모리 주소("주소1")**를 가리킵니다.
그래서 둘 중 하나를 수정하면 서로 영향을 줍니다.

```js
obj3.a = 999;
console.log(obj.a); // 999
```

✅ 객체 자체도 공유,
✅ 내부 배열도 공유

### 2️⃣ 얕은 복사 (1단계까지만 새 주소)

```js
const obj2 = { ...obj };
```

obj2는 새로운 주소에 복사됩니다. 예: "주소2"
하지만 내부에 있던 배열 b는 그대로 "주소배열"을 참조합니다.

즉, depth 1단계까지만 다른 주소로 복사합니다

```js
obj2.a = 555;
// 독립적 a  => const obj2 = { a: 555, b: [10, 20, 30] };
// a는 영향x => const obj = { a: 1, b: [10, 20, 30] };

obj2.b[0] = 777;
// 비독립적 b =>  const obj2 = { a: 1, b: [777, 20, 30] };
// 원본 b 영향 o => const obj = { a: 1, b: [777, 20, 30] };
```

🧠 구조 요약

```css

obj  ──▶ { a: 1, b: ──▶ [10, 20, 30] } ← "주소1" (원본)
obj3 ──┘      ↑
              └──── 같은 참조

obj2 ──▶ { a: 1, b: ──▶ [10, 20, 30] } ← "주소2" (얕은 복사)
                         ↑
                         └──── 같은 배열 참조 ("주소배열")
```

---

| 항목           | 객체 주소 | 배열 주소 (`b`) |
| -------------- | --------- | --------------- |
| `obj`          | "주소1"   | "주소배열"      |
| `obj3 = obj`   | "주소1"   | "주소배열"      |
| `obj2 = {...}` | "주소2"   | "주소배열"      |

---

### 3️⃣ 깊은 복사 (내부까지 전부 새 주소)

내부까지 완전히 복사해서 참조 공유를 끊는 방법입니다.
즉, 모든 depth 의 주소를 새 주소로 변경합니다

🔨 방법 1: structuredClone (최신 브라우저 지원)

```js
const obj4 = structuredClone(obj);
obj4.b[0] = 999;

console.log(obj.b[0]); // 10 → 영향 없음!
```

🔨 방법 2: JSON 방식 (단, 함수나 순환참조는 안 됨)

```js
const obj4 = JSON.parse(JSON.stringify(obj));
```

```css
obj4 ──▶ { a: 1, b: ──▶ [10, 20, 30] } ← 전부 새 주소!
```

---

| 항목           | 객체 주소 | 배열 주소 (`b`) |
| -------------- | --------- | --------------- |
| `obj`          | "주소1"   | "주소배열"      |
| `obj3 = obj`   | "주소1"   | "주소배열"      |
| `obj2 = {...}` | "주소2"   | "주소배열"      |
| `obj4`         | "주소4"   | "주소배열4"     |

## ✅ 정리: 얕은 복사 vs 깊은 복사 비교표

| 구분      | 객체 주소 새로 생성  | 내부 참조도 새로 생성      | 원본 영향 여부    |
| --------- | -------------------- | -------------------------- | ----------------- |
| 참조 복사 | ❌ (같은 주소)       | ❌ (같은 주소)             | ✅ 영향 받음      |
| 얕은 복사 | ✅ (1단계만 새 주소) | ❌ (중첩 객체/배열은 공유) | ❗ 일부 영향 있음 |
| 깊은 복사 | ✅                   | ✅                         | ❌ 완전히 독립됨  |

---

# 🍀 데이터 타입 배경지식

## 📌 저장공간

컴퓨터는 모든 데이터를 0 또는 1로 바꿔서 기억한다
0 또는 1을 표현할 수 있는 하나의 메모리 조각을 `비트`라고 한다

많은 비트를 한단위로 묶으면 낭비되는 비트가 생길 수 있지만 표현 가능한 데이터 개수도 늘어난다
그래서 생긴게 `바이트` 개념이다
바이트는 8개의 비트로 구성되있고
1바이트는 2*2*2*2*2*2*2\*2 인 256개의 값을 표현할 수 있다

C나 자바의 경우 메모리 상황이 좋지 않은 상태에서 생긴 언어이기 때문에 타입별로 2바이트/4바이트 등으로 미리 구분지어 놨다
하지만 메모리 용량이 월등이 커진 상황에서 등장한 자바스크립트는
상대적으로 메모리 압박에 자유로워져서 데이터 타입을 구분하지않고 전부 8바이트를 확보한다

## 📌 변수 선언

```js
var = a; // 선언

a = "abc";  // 할당
```

![](https://velog.velcdn.com/images/ckx12/post/6c1baa70-02dd-4ce6-b1c1-2b81e979f72c/image.jpg)

위 과정을 보면 `1003`의 값에 직접 "abc"를 넣는 게 아닌
한단계를 더 거쳐서 값을 넣는다
그 이유는 데이터 변환에 자유와 메모리 효율성 때문이다

미리 확보해 놓은 공간내에서만 데이터 변환을 한다면,
해당 공간을 변화되는 데이터 크기에 맞게끔 늘리는 작업이 필요하다
만약 중간에 있는 데이터 공간을 사용중이라면, 뒤에 있는 애들을 밀고 다시 저장해야되는 비효율적인 연산이 많아진다

또한, 500개의 데이터에 같은 값이 5을 저장하려고 하면
변수 공간 500개를 확보하여 5를 저장하는 대신
하나의 5를 저장하고 주소를 이용하는 방식이 효율적이다

**그래서 변수와 데이터를 별도의 공간으로 나눠서 저장하는게 최적이다**

## 📌 변수 재할당

```js
a = "abcdef";
```

재할당을 한다면
기존의 "abc" 공간에 "abc + def" 형식으로 저장하는게 아니라
새로운 공간을 확보하고
해당 공간에 "abcdef"를 저장하고 기존 변수 영역의 값에 대입한다

![](https://velog.velcdn.com/images/ckx12/post/a4c7dcdd-89b8-4a11-836c-cf2aa963f7e9/image.jpg)

## 📌 불변값

```js
var a = "abc";

a = a + "def";
```

위에서는 같은 a에 값을 할당하고 있다
하지만
결과물인 "abc"와 "abcdef"는 아예 다른 별개의 데이터다

```js
var b = 5;
var c = 5;

b = 7;
```

위 코드를 실행해보면
먼저, 변수영역에 b를 선언하고
데이터 영역에서 5를 찾는다. 없다면 새로운 공간에 5를 저장한다
그리고 저장한 주소를 변수b에 저장한다

다음, 변수영역에 c를 선언하고
데이터 영역에서 5를 찾는다. 이미 5가 존재하기 때문에 해당 주소를 변수c에 저장한다(재활용)

마지막 줄에서, 데이터영역에서 7을 찾고, 없다면 새로운 공간에 7을 저장한다.
그리고 저장한 주소를 새로 변수b에 저장한다(재할당)

두가지 예제를 보면,
문자열이든 숫자든
**한번 만든 값은 다른 값으로 변경 할 수없다
오로지 새로 만들어 교체하는 과정만 존재한다**
이것이 `불변값`의 성질이다

## 📌 가변값

참조형 데이터는 기본적으로는 가변값이다 (불변값을 설정하지 않는 이상)

```js
var obj1 = {
  a: 1,
  b: "bbb",
};
```

![](https://velog.velcdn.com/images/ckx12/post/ebff92bf-c805-4493-88c3-c08a39ecc761/image.jpg)

1. 먼저 변수 영역에 **빈공간(1002)을 만들고**, 변수명을 `obj1`로 지정
2. 데이터영역에서 **저장공간(5001)을 확보**하고, 값을 저장하려고 하니 여러값의 데이터 -> **별도의 변수 영역(7100~)**을 마련하고 해당 주소를 저장
3. 별도의 객체 5001영역에서, 각각의 프로퍼티 이름을 저장
4. 프로퍼티 값은 데이터영역에서 찾아서 있으면 대입, 없으면 새로 생성

기본형 데이터와의 차이점은 객체의 변수 영역이 별도로 존재한다는 점이다
하지만 이도 변수영역을 별도로 지정할 뿐, 기존 변수 영역과 동일한 데이터 영역을 사용한다 (불변값 유지)

**이는 참조형 데이터도 불변성을 가지는 것처럼 보인다 **
하지만 변수에 얼마든지 다른 값 대입이 가능하다

### 💡 가변값 재할당

```js
var obj1 = {
  a: 1,
  b: "bbb",
};

obj1.b = 2;
```

1~4과정을 끝낸 후,
데이터 영역에서 2를 검색 후 없다면 새로운 공간 확보 후 저장하고 해당 주소를 **객체 영역에 저장**한다
하지만 기존 obj1이 바라보고 있는 값의 주소는 **5001로 이전과 동일**하다
즉, 새로운 객체 생성이 아닌
객체 내부의 값만 변경된 것이다

![](https://velog.velcdn.com/images/ckx12/post/5da8b0eb-a2ae-4ded-b970-27f90ca9c635/image.jpg)

### 💡 중첩객체

```js
var obj1 = {
  x: 3,
  arr: [1, 2, 3],
};
```

1. 변수영역에 obj1 저장하고, 값 주소를 5001로 저장
2. 데이터 영역 5001에 저장되는 값이 여러값이라 별도의 영역 7103~을 마련하고 해당 주소를 5001에 저장
3. 별도 객체 영역에 프로퍼티 이름을 각각 저장 (x, arr)
4. 첫번째 프로퍼티의 값인 1을 데이터 영역에서 찾고, 없으면 별도의 공간에 저장, 해당 주소를 객체영역에 저장
5. 두번째 프로퍼티 값을 저장하려고 하니, 여러 값 => 새로운 배열 변수 영역을 만들고 인덱싱하여 차례대로 저장
6. 변수 영역에서 각각의 값을 데이터 영역에서 찾고, 없으면 공간 확보 후, 주소를 배열 영역에 저장

![](https://velog.velcdn.com/images/ckx12/post/f7e4d633-bfbe-47cc-b2f4-c3fb0b3f6f2d/image.jpg)

### 💡 재할당

```js
obj.arr = "str";
```

위 배열을 문자열로 재할당한다면 ?

1. 데이터영역에서 "str" 값을 찾고, 없다면 공간 확보 후 저장
2. 해당 주소를 객체 영역에서 arr프로퍼티의 값으로 저장
3. 기존에 있던 배열영역의 참조 카운트가 기존에 1에서 0으로 변경
4. 참조 카운터 0은 `가비지 컬랙터(GC)` 대상이 되어 메모리 포화 시 수거 됨

![](https://velog.velcdn.com/images/ckx12/post/a3ad926f-a3c0-4046-9753-f817716557bb/image.jpg)

## 📌 변수 복사

```js
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
```

⭐ 기본형
선언

1. 변수영역에 a 확보 후, 데이터영역에 10을 저장하고 연결 (5001)
   복사
2. 변수영역에 b 확보 후, 식별자 a를 검색하여 주소값인 5001을 확보 후 변수 b의 값에 대입

⭐ 참조형
선언

1. 변수영역에 obj1 확보 후, 값 5002 저장
2. 5002는 여러값이라 별도의 객체 영역확보 후 프로퍼티 이름 저장
3. 각 값을 데이터영역에서 검색/저장 후 저장
   복사
4. 변수영역에 obj2 확보 후, obj1의 값 주소값인 5002를 obj2 값에 저장

![](https://velog.velcdn.com/images/ckx12/post/769cde26-d476-433d-8569-81d7dd9ef6ab/image.jpg)

👉 기본형과 참조형 모두 값의 주소가 동일해졌음

### 💡 재할당

```js
b = 15;

obj2.c = 20;
```

⭐ 기본형

1. 데이터영역에 15를 검색, 없으면 공간 확보 후 5004에 저장
2. 5004 주소를 b의 값 에 대입 = 주소 변경

⭐ 참조형

1. 데이터영역에서 20을 검색, 없으면 공간 확보 후, 5005에 저장
2. 5005 주소를 7103의 값에 대입

![](https://velog.velcdn.com/images/ckx12/post/27e9ec8c-884d-42dd-95c8-e230d10b6446/image.jpg)

## 🎯 결과

기본형의 경우 재할당 시,
동일한 주소로 복사하고 시작했지만,
값의 주소가 변경되는 결과가 나타났고

참조형의 경우 재할당 시,
동일 주소 시작, 동일 주소 끝으로 결과가 나타났다

대부분 책은 기본형은 값을 복사, 참조형은 주솟값을 복사한다고 설명하지만
사실 자바스크립트의 모든 데이터는 사실 참조형 데이터이다

하지만 **기본형은 주솟값을 복사하는 과정이 한번만 이뤄지고
참조형은 한단계를 더 거치게 되는 차이가 있다
**

참조형의 경우에도 내부 프로퍼티의 값 변경이 아닌 객체 자체를 변경해버리면 기본형과 동일한 결과가 나타난다

```js
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2 = { c: 20, d: "ddd" };
```

![](https://velog.velcdn.com/images/ckx12/post/de3368e5-236e-4914-934c-98bc27c99542/image.jpg)
